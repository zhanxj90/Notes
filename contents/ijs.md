# Interesting JavaScript
> 枯燥的知识千篇一律，有趣的js万里无一

## typeof null == Object
  1. 在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

## [] == ! []
  ```js
    console.log([] == ![]) // true
  ```
  1. 步骤：[] == ! []   ->   [] == false  ->  [] == 0  ->   '' == 0   ->  0 == 0   ->  true
  2. 解析：
    - ！ 的优先级大于 == ，所以先执行 ![]; ![]=false
    - 根据比较运算符转换规则（ [具体规则详情](./js.md/#比较运算符) ),布尔值先转换成数值；则变成：[] == 0
    - 有个是对象，另一个不是则把对象变成基本类型(调用toPrimitive转换成Number,最终调用的是toString)：[] = ‘’
    - 比较变成了：‘’ == 0 , 字符和数值比较会把字符转换成数值：0 == 0

## {} == !{}
  ```js
    console.log({} == !{}) // false
  ```
  1. 步骤：{} == !{}   ->   {} == false  ->  {} == 0  ->   NaN == 0   ->  false
  2. 解析：
    - 解析步骤同上述 [] == ! []
    - 区别在于步骤3，调用toPrimitive，（ {}.toString() ->  NaN(返回的是NaN) ）：{} = NaN

## 非匿名自执行函数特性
  ```js
    (function b(){
        b=20;
        console.log(b)
    })();
  ```
  1. 输出结果：
    ```js
      ƒ b(){
        b=20;
        console.log(b)
      }
    ```
  2. 原因：非匿名自执行函数，函数名只读。但是可以使用let、var等重新定义变量b，b=20改为var b=20，则打印20