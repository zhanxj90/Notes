# 专业术语（陌生就对了）

## 支付幂等
### *支付幂等性*
  1. 幂等性定义
      - 前端重复提交选中的数据，后台应该只产生对应本次提交的一个响应结果。
      - 用户发起一笔付款请求，应该只扣除用户账号一次钱，即使遇到网络重发或系统bug重发时，也只扣除一次钱。
      - 创建业务订单时，一次业务请求只能创建一个订单
  2. 实现幂等
    需要有唯一标识来标记请求，比如订单号，token等。

-----

## javascript沙箱
### *js沙箱概念*
  1. 沙箱就是js中一块完全独立的区域,使用的都是自己独立的属性和方法
### *js沙箱的基本格式*
  2. js中沙箱的基本格式:自调用函数(立即执行函数)
      ```js
      (function(){})()
      ```
### *js沙箱的使用规范*
  1. 所有的变量定义 写在最上方
  2. 中间放逻辑代码
  3. 最后,如果需要就给外界暴露一些成员(比如jQuery的,例如:window.$=window.jQuery=$)
### *js沙箱的用途*
  1. 书写第三方框架
  2. 为第三方框架书写插件
  3. 书写功能独立的一些组件
### *沙箱模式的优势*
  1. 沙箱模式使用的是IIFE，不会再外界暴露任何的全局变量，也就不会造成全局变量污染
  2. 沙箱中的所有数据，都是和外界完全隔离的，外界无法对其进行修改，也就保证了代码的安全性

-----

## .gitkeep文件
  1. .gitkeep 文件是创建在一个空目录下的标识性文件，其作用是为了使 Git 保留该空目录(在有了 .gitkeep 文件后就不是空目录了)。
  2. .gitkeep 文件的文件名是社区的一个约定，仅仅只是为了起到一个统一的目的，使开发者在看到该文件时就知道其作用。
  3. .gitkeep 文件和官方没有任何关系，并不是官方定义的 Git 的系统文件。
  4. .gitkeep 文件应该是一个目录下的唯一文件，当该目录下有了其他文件时，就应该删除 .gitkeep 文件。
  5. .gitkeep 文件和 .gitignore 文件没有任何关系；前者是为了使 Git 保留一个空目录，后者是为了使 Git 忽略某些指定的文件。
  6. .gitkeep 文件并不是强制规定，只是一个约定，完全可以用自己喜欢的方式，但 .gitkeep 文件无疑是被大多数开发者所承认的一个约定或者说是最佳实践，推荐使用

-----

## Lorem
  1. 乱数假文,来源于印刷术术语，为展示排版而生成的一段无实际含义的文本内容；
  2. vscode的快捷指令：lorem4--生成一段4个单词的文本内容

-----

## 猴子补丁
  1. 在函数原型中加入成员，以增强其对象的功能，猴子补丁会导致原型污染，使用需谨慎。

-----

## 前端工程化
  1. 工程化是一种思想而不是某种技术;前端工程化就是用做工程的思维看待和开发自己的项目,而不再是直接撸起干
  2. 前端工程化的主要目标就是解放生产力，提高生产效率，通过一系列的规范，借助工具和框架解决前端开发以及前后端协作的一些问题。
  3. 前端工程化可以分成四个方面来说，分别为模块化、组件化、规范化和自动化。
### *前端模块化*
  1. 模块化是指将一个文件拆分成多个相互依赖的文件，最后进行统一的打包和加载，这样能够很好的保证高效的多人协作
  2. 一个模块就是一个实现特定功能的文件，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。
  3. 模块化是对文件、对代码和资源拆分
  4. 模块化开发的好处：
      - 避免变量污染，命名冲突
      - 提高代码复用率
      - 提高维护性
      - 依赖关系的管理
### *前端组件化*
  1. 页面上的每个独立的、可视/可交互区域视为一个组件;
  2. 每个组件对应一个工程目录,组件所需的各种资源都在这个目录下就近维护;
  3. 由于组件具有独立性,因此组件与组件之间可以 自由组合;
  4. 页面只不过是组件的容器,负责组合组件形成功能完整的界面;
  5. 当不需要某个组件,或者想要替换组件时,可以整个目录删除/替换。
### *规范化*
  1. 规范化指的是我们在工程开发初期以及开发期间制定的系列规范
  2. 应用方面：
      - 项目目录结构
      - 编码规范：ESLint、StyleLint 等。
      - 联调规范
      - 文件命名规范
      - 样式管理规范：目前流行的样式管理有 BEM、Sass、Less、Stylus、CSS Modules 等方式。
      - git flow 工作流：其中包含分支命名规范、代码合并规范等。
      - 定期 code review（检查代码） … 
### *自动化*
  1. 自动化工具（自动化合并、构建、打包）：
      - [grunt](https://www.gruntjs.net/) 
      - [gulp](https://www.gulpjs.com.cn/)
      - [webpack](https://www.webpackjs.com/)
      - [parcel](https://zh.parceljs.org/)
  2. 持续集成
  3. 自动化测试...

-----

## Comet
### *概念*
  1. 服务器推送技术(Server Push),别名叫Comet(彗星）
  2. 基于 HTTP长连接的“服务器推”技术，是一种新的 Web 应用架构
  3. 基于这种架构开发的应用中，服务器端会主动以异步的方式向客户端程序推送数据，而不需要客户端显式的发出请求。
### *实现模型*
  1. 两种 Comet 应用的实现模型:
      - 基于 AJAX 的长轮询（long-polling）方式
      - 基于 Iframe 及 htmlfile 的流（streaming）方式
### *优缺点*
  1. 优 点：实时性好（消息延时小）；性能好（能支持大量用户）
  2. 缺点：长期占用连接，丧失了无状态高并发的特点。

-----

## 鸭子辩型法
  1. 概念：像鸭子一样走路、游泳和嘎嘎叫的鸟就是鸭子；在js中就是通过一个标准去判断某个类型，只要符合这个标准就是这个类型
  2. 用途：一般用在模拟接口的实现。

----- 

## 里式替换原则
### *概述*
  1. 出现在面向对象中，是对子类型的特别定义
  2. 子类的对象，始终可以赋值给父类；```let p:Father=new Son();class Son extend Fatther{}```
  3. 子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
### *主要作用*
  1. 实现开闭原则的重要方式之一。
  2. 克服了继承中重写父类造成的可复用性变差的缺点。
  3. 是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
  4. 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。
### *具体定义*
  1. 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
  2. 子类中可以增加自己特有的方法
  3. 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松
  4. 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等

-----

## 函数柯里化
### *释义*
  1. 柯里化（Currying）:计算机科学中，是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回新函数(新函数-接受余下的参数且返回结果)的技术。
  2. 这个技术由 Christopher Strachey 以逻辑学家 Haskell Curry 命名的，尽管它是 Moses Schnfinkel 和 Gottlob Frege 发明的。
  3. 柯里化函数：js中，固定某个函数的一些参数，得到该函数剩余参数的一个新函数，如果没有剩余参数，则调用
### *实现*
  1. 原函数固定参数数量的
      ```js
        function curry() {
          var fn = arguments[0]; // 获取要执行的函数
          var args = [].slice.call(arguments, 1); // 获取传递的参数，构成一个参数数组
          // 如果传递的参数已经等于执行函数所需的参数数量
          if (args.length === fn.length) {
              return fn.apply(this, args)
          }
          // 参数不够向外界返回的函数
          function _curry(){
              // 推入之前判断
              // 将新接收到的参数推入到参数数组中
              args.push(...arguments);
              if(args.length === fn.length){
                  return fn.apply(this, args)
              }
              return _curry;
          }
          return _curry;
        }
      ```
  2. 进阶--累加（不确定参数数量）
      ```js
        function add() {
          // 第一次执行时，定义一个数组专门用来存储所有的参数
          var _args = Array.prototype.slice.call(arguments);

          // 在内部声明一个函数，利用闭包的特性保存 _args 并收集所有的参数值
          var _adder = function () {
              _args.push(...arguments);
              return _adder;
          };

          // 这个是最后输出的时候被调用的，return 后面如果是函数体，
          // 为了输出函数体字符串会自动调用 toString 方法
          // 利用 toString 隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
          _adder.toString = function () {
              return _args.reduce(function (a, b) {
                  return a + b;
              });
          }

          // 这个 return 是第一次调用的时候返回上面的函数体，
          // 这样后面所有的括号再执行的时候就是执行 _adder 函数体
          return _adder;
        }
        console.log(add(1)(2)(3).toString()); // 6
        console.log(add(1, 2, 3)(4).toString()); // 10
      ```

-----

## 函数管道
### *释义*
  1. 将多个单参数函数组合起来，形成一个新的函数，这些函数中，前一个函数的输出会作为后一个函数的输入。
### *注意事项*
  1. 前提条件：传入的函数一定都是单参，不然多出来的参数获取不到，也无法处理
  2. 有多参函数的话，可以使用柯里化把该函数转成单参
### *实现*
  1. 写法一
      ```js
        function pipe(){
          let args=Array.from(arguments)
          return function(val){
            for(let i=0;i<args.length;i ++){
              let func=args[i]
              val=func(val)
            }
            return val
          }
        }
      ```
  2. 写法二
      ```js
        function pipe(){
          let args=Array.from(arguments)
          return function(val){
            return args.reduce((result,func)=>func(result),val)
          }
        }
      ```